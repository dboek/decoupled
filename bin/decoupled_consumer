#!/usr/bin/env ruby
# coding: utf-8
#require 'rubygems'

# Load all files in the directory decoupled is started from
$LOAD_PATH[0,0] = File.join(File.dirname(__FILE__), '..', 'lib')
$LOAD_PATH << Dir.pwd
#$LOAD_PATH << '.'

require 'rubygems'
require 'optparse'
require 'redis'
require 'decoupled'

options = {}

optparse = OptionParser.new do |opts|
  
  opts.on('-q', '--queue-name QUEUE_NAME', "name of the queue this consumer will subscribe to") do |queue_name|            
    options[:queue_name] = queue_name
  end

  opts.on('-k', '--job-klass JOB_KLASS', "Please specify a Class Template where Your Jobs will be executed in") do |job_klass|
    options[:job_klass] = job_klass
  end

  options[:concurrent_count] = 3
  opts.on('-c', '--job-count JOB_COUNT', Integer, "Number of message the consumer will process in parallel (default => #{options[:concurrent_count]})") do |concurrent_count|            
    options[:concurrent_count] = concurrent_count
  end       
  
  options[:environment] = 'development'
  opts.on('-e', '--environment DECOUPLED', "decoupled environment can be used in the jobs (default => #{options[:environment]})") do |environment|           
    options[:environment] = environment
  end

  options[:amqp_host] = 'localhost'
  opts.on('-a', '--amqp_host localhost', "amqp server you want to connect to (default => #{options[:amqp_host]})") do |amqp_host|           
    options[:amqp_host] = amqp_host
  end

  opts.on('-h', '--help', 'Help messages') do     
    puts opts                     
    exit    
  end       
end

begin       
  optparse.parse!                 
  mandatory = [:queue_name, :concurrent_count, :job_klass]
  missing = mandatory.select{ |param| options[param].nil? }        
  if not missing.empty?
    puts "Missing options: #{missing.join(', ')}"                  
    puts optparse      
    exit               
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument  
  puts $!.to_s         
  puts optparse        
  exit
end

ENV['DECOUPLED'] = options[:environment]

require Decoupled::String.underscore(options[:job_klass])

begin
  puts 'starting Decoupled Consumer with:'
  puts "environment:      #{options[:environment]}"
  puts "concurrent_count: #{options[:concurrent_count]}"
  puts "job_klass:        #{options[:job_klass]}"

  @consumer = Decoupled::Consumer.new(options)
  @consumer.start

  trap("INT") { 
    puts 'shutting down decoupled, can take some time...'
    loop = false
    @consumer.close_connections

    exit 2
  }
rescue => e
  puts "error #{e}"
  @consumer.close_connections
end

